diff --git a/modules/db_kazoo/blf.c b/modules/db_kazoo/blf.c
index 34d1085..e58b540 100644
--- a/modules/db_kazoo/blf.c
+++ b/modules/db_kazoo/blf.c
@@ -39,12 +39,13 @@ int dbk_initialize_pres_htable(void);
 #define BLF_JSON_USER      "User"
 #define BLF_JSON_QUEUE     "Queue"
 #define BLF_JSON_EXPIRES   "Expires"
-#define BLF_APP_NAME       "App-Name"
-#define BLF_APP_VERSION    "App-Version"
-#define BLF_NODE           "Node"
-#define BLF_SERVERID       "Server-ID"
-#define BLF_EVENT_CATEGORY "Event-Category"
-#define BLF_EVENT_NAME     "Event-Name" 
+#define BLF_JSON_APP_NAME       "App-Name"
+#define BLF_JSON_APP_VERSION    "App-Version"
+#define BLF_JSON_NODE           "Node"
+#define BLF_JSON_SERVERID       "Server-ID"
+#define BLF_JSON_EVENT_CATEGORY "Event-Category"
+#define BLF_JSON_EVENT_NAME     "Event-Name" 
+#define BLF_JSON_TYPE           "Type" 
 
 static char blf_queue_name_buffer[128];
 static amqp_bytes_t blf_queue;
@@ -147,17 +148,19 @@ void rmqp_consumer_loop(struct db_id* id)
 	LM_INFO("Created rmqp connection\n");
 	/* Declare reply queue and start consumer */
 
-	amqp_exchange_declare(rconn->conn, rconn->channel, amqp_cstring_bytes("dialoginfo"), amqp_cstring_bytes("fanout"),
-//	amqp_exchange_declare(rconn->conn, rconn->channel, amqp_cstring_bytes("dialoginfo"), amqp_cstring_bytes("direct"),
-                        0, 0, amqp_empty_table);
+//	amqp_exchange_declare(rconn->conn, rconn->channel, amqp_cstring_bytes("dialoginfo"), amqp_cstring_bytes("fanout"),
+	amqp_exchange_declare(rconn->conn, rconn->channel, amqp_cstring_bytes("dialoginfo"), amqp_cstring_bytes("direct"),
+                       1, 1, amqp_empty_table);
 	if (rmq_error("Declaring exchange", amqp_get_rpc_reply(rconn->conn))) {
 		goto error;
 	}
 
+
 	amqp_queue_declare(rconn->conn, rconn->channel, blf_queue, 0, 0, 1, 1, amqp_empty_table);
 	if (rmq_error("Declaring queue", amqp_get_rpc_reply(rconn->conn))) {
 		goto error;
 	}
+	LM_INFO("Queue declare was successful\n");
 
 	amqp_queue_bind(rconn->conn, rconn->channel, blf_queue, exch, routing_key, amqp_empty_table);
 	if (rmq_error("Binding queue", amqp_get_rpc_reply(rconn->conn))) {
@@ -253,7 +256,7 @@ void rmqp_consumer_loop(struct db_id* id)
 		}
 
 		body[body_received] = '\0';
-		LM_INFO("Received reply %s\n", body);
+		LM_INFO("Received update %s\n", body);
 	
 		if ( rmqp_pres_update_handle(body) < 0) {
 			LM_ERR("Failed to add to the update queue\n");
@@ -758,7 +761,6 @@ error:
 	dbk_free_xml(body);
 	return -1;
 }
-
 #define json_extract_field(json_name, field)  do { \
 	struct json_object* obj = json_object_object_get(json_obj, json_name); \
 	if (is_error(obj)) { \
@@ -775,17 +777,70 @@ error:
 } while (0);
 
 
+int rmqp_pres_flush_handle(struct json_object* json_obj)
+{
+	str type={0, 0};
+	dbk_pres_user_t* pu;
+
+	json_extract_field(BLF_JSON_TYPE, type);
+
+	if (type.len == 3 && strcmp(type.s, "all") == 0) {
+		int i;
+		dbk_pres_user_t* pu_next;
+		for (i = 0; i< dbk_phtable_size; i++) {
+			lock_get(&dbk_phtable[i].lock);
+			pu = dbk_phtable[i].pu;
+			dbk_phtable[i].pu = NULL;
+			lock_release(&dbk_phtable[i].lock);
+
+			for (; pu; pu = pu_next) {
+				pu_next = pu->next;
+				dbk_free_pu(pu);
+			}
+		}
+	} else {
+		str user;
+		int hash_code;
+		dbk_pres_user_t* pu_prev = NULL;
+
+		json_extract_field(BLF_JSON_USER, user);
+		hash_code = core_hash(&user, NULL, dbk_phtable_size);
+		lock_get(&dbk_phtable[hash_code].lock);
+		pu = dbk_pres_search_pu(hash_code, &user, &pu_prev, 0);
+		if (pu == NULL) {
+			LM_INFO("FLUSH: No record found for user %.*s\n", user.len, user.s);
+			lock_release(&dbk_phtable[hash_code].lock);
+		} else {
+			if (pu_prev) { 
+				pu_prev->next = pu->next;
+			} else {
+				dbk_phtable[hash_code].pu = pu->next;
+			}
+			lock_release(&dbk_phtable[hash_code].lock);
+			dbk_free_pu(pu);
+		}
+	}
+	return 0;
+error:
+	return -1;
+}
+
+
+
 /*
  * presence update: json format
  * {"From": "uri", "To": "uri", "State": "state", "Callid": "callid", "From-Tag": "tag", "To-Tag": "tag"}
  * {"Replaces": "", "Refered-By": ""}
  * */
+
 int rmqp_pres_update_handle(char* req)
 {
 	str from_user={0, 0}, to_user= {0, 0};
 	str callid= {0, 0}, fromtag= {0, 0}, totag= {0, 0};
 	str state= {0, 0};
+	str event_name={0, 0};
 	struct json_object *json_obj;	
+	int ret = 0;
 
 	/* extract info from json and construct xml */
 	json_obj = json_tokener_parse(req);
@@ -794,24 +849,33 @@ int rmqp_pres_update_handle(char* req)
 		goto error;
 	}
 
-	json_extract_field(BLF_JSON_FROM, from_user);
-	json_extract_field(BLF_JSON_TO, to_user);
-	json_extract_field(BLF_JSON_CALLID, callid);
-	json_extract_field(BLF_JSON_FROMTAG, fromtag);
-	json_extract_field(BLF_JSON_TOTAG, totag);
-	json_extract_field(BLF_JSON_STATE, state);
+	json_extract_field(BLF_JSON_EVENT_NAME, event_name);
 
-	if ( !from_user.len || !to_user.len || !callid.len || !state.len) {
-		LM_ERR("Wrong formated json %s\n", req);
-		json_object_put(json_obj);
-		goto error;
-	}
+	if ( event_name.len == 5 && strncmp(event_name.s, "flush", 5) == 0 ) {
+		ret = rmqp_pres_flush_handle(json_obj);
+	} else {
 
-	dbk_pres_update_and_notify(&from_user, &to_user, &callid, &fromtag, &totag, &state, 1);
-	dbk_pres_update_and_notify(&to_user, &from_user, &callid, &totag, &fromtag, &state, 0);
+		json_extract_field(BLF_JSON_FROM, from_user);
+		json_extract_field(BLF_JSON_TO, to_user);
+		json_extract_field(BLF_JSON_CALLID, callid);
+		json_extract_field(BLF_JSON_FROMTAG, fromtag);
+		json_extract_field(BLF_JSON_TOTAG, totag);
+		json_extract_field(BLF_JSON_STATE, state);
 
+		if ( !from_user.len || !to_user.len || !callid.len || !state.len) {
+			LM_ERR("Wrong formated json %s\n", req);
+			json_object_put(json_obj);
+			goto error;
+		}
+
+		if (dbk_pres_update_and_notify(&from_user, &to_user, &callid, &fromtag, &totag, &state, 1) < 0 ||
+			dbk_pres_update_and_notify(&to_user, &from_user, &callid, &totag, &fromtag, &state, 0) < 0) {
+			LM_ERR("Failed to process dialoginfo update command\n");
+			ret = -1;
+		}
+	}
 	json_object_put(json_obj);
-	return 0;
+	return ret;
 error:
 	return -1;
 }
@@ -1046,6 +1110,8 @@ int dbk_dialoginfo_update(const db1_con_t* _h, const db_key_t* db_col,
 	json_object_object_add(json_object, BLF_JSON_CALLID, json_object_new_string_len(callid.s, callid.len));
 	json_object_object_add(json_object, BLF_JSON_FROMTAG, json_object_new_string_len(from_tag.s, from_tag.len));
 	json_object_object_add(json_object, BLF_JSON_TOTAG, json_object_new_string_len(to_tag.s, to_tag.len));
+	json_object_object_add(json_object, BLF_JSON_EVENT_CATEGORY, json_object_new_string("presence"));
+	json_object_object_add(json_object, BLF_JSON_EVENT_NAME, json_object_new_string("update"));
 	
 	amqp_mb.bytes = (char*)json_object_to_json_string(json_object);
 	if (amqp_mb.bytes == NULL) {
@@ -1196,12 +1262,12 @@ int dbk_presence_subscribe_alert_kazoo(rmq_conn_t* rconn, str* user,unsigned int
 	json_object_object_add(json_object, BLF_JSON_USER, json_object_new_string_len(user->s, user->len));
 	json_object_object_add(json_object, BLF_JSON_QUEUE, json_object_new_string_len(blf_queue.bytes, blf_queue.len));
 	json_object_object_add(json_object, BLF_JSON_EXPIRES, json_object_new_int(expires-(int)time(NULL)));
-	json_object_object_add(json_object, BLF_APP_NAME, json_object_new_string(NAME));
-	json_object_object_add(json_object, BLF_APP_VERSION, json_object_new_string(VERSION));
-	json_object_object_add(json_object, BLF_NODE, json_object_new_string(node_name));
-	json_object_object_add(json_object, BLF_SERVERID, json_object_new_string(""));
-	json_object_object_add(json_object, BLF_EVENT_CATEGORY, json_object_new_string("presence"));
-	json_object_object_add(json_object, BLF_EVENT_NAME, json_object_new_string("subscription"));
+	json_object_object_add(json_object, BLF_JSON_APP_NAME, json_object_new_string(NAME));
+	json_object_object_add(json_object, BLF_JSON_APP_VERSION, json_object_new_string(VERSION));
+	json_object_object_add(json_object, BLF_JSON_NODE, json_object_new_string(node_name));
+	json_object_object_add(json_object, BLF_JSON_SERVERID, json_object_new_string(""));
+	json_object_object_add(json_object, BLF_JSON_EVENT_CATEGORY, json_object_new_string("presence"));
+	json_object_object_add(json_object, BLF_JSON_EVENT_NAME, json_object_new_string("subscription"));
 
 	amqp_mb.bytes = (char*)json_object_to_json_string(json_object);
 	if (amqp_mb.bytes == NULL) {
